
*** These modified files were found in JOE when it aborted on Tue Feb 11 20:47:02 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
copyConst.hpp
copyConst.cpp
copyConst.hpp
copyConst.hpp
copyConst.cpp
copyConst.hpp
assign1_test.cpp
assign1_test.cpp
money.hpp
money.hpp
ordered_array.cpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Tue Feb 11 20:47:02 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
copyConst.hpp
copyConst.cpp
copyConst.hpp
copyConst.hpp
copyConst.cpp
copyConst.hpp
assign1_test.cpp
assign1_test.cpp
money.hpp
money.hpp
ordered_array.hpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Tue Feb 11 20:47:02 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
copyConst.hpp
copyConst.cpp
copyConst.hpp
copyConst.hpp
copyConst.cpp
copyConst.hpp
assign1_test.cpp
assign1_test.cpp
money.hpp
money.hpp
ordered_array.hpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Tue Feb 11 20:47:02 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
copyConst.cpp
copyConst.hpp
assign1_test.cpp
assign1_test.cpp
money.hpp
money.hpp
ordered_array.hpp
assign1_test.cpp
assign1_test.cpp
assign1_test.cpp
assign1_test.cpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Tue Feb 11 20:47:02 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
copyConst.hpp
assign1_test.cpp
assign1_test.cpp
money.hpp
money.hpp
ordered_array.hpp
assign1_test.cpp
assign1_test.cpp
assign1_test.cpp
ordered_array.hpp
assign1_test.cpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Tue Feb 11 21:21:37 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
assign1_test.cpp
ordered_array.hpp
ordered_array.hpp
assign1_test.cpp
assign1_test.cpp
assign1_test.cpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Tue Feb 11 21:21:37 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
money.hpp
money.hpp
ordered_array.hpp
assign1_test.cpp
assign1_test.cpp
assign1_test.cpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
assign1_test.cpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Tue Feb 11 21:21:37 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Tue Feb 11 21:21:37 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
assign1_test.cpp
assign1_test.cpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Tue Feb 11 21:21:37 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
assign1_test.cpp
ordered_array.hpp
ordered_array.hpp
assign1_test.cpp
assign1_test.cpp
ordered_array.hpp
ordered_array.hpp
assign1_test.cpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Tue Feb 11 23:04:31 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
assign1_test.cpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Tue Feb 11 23:04:31 2020
*** JOE was aborted by UNIX signal 15

*** File 'ordered_array.hpp'
#include <stdexcept> // For out_of_range
#include <iostream>

class ordered_array {
  public:
    /* constructor
       Construct a new ordered_array with the given capacity (maximum size).
       The size of a new ordered_array should be 0.
    */

    ordered_array(int cap) 
	{ 
//	pointer = new int[cap];
	capac = cap;
	size2 =0;
	pointer = new int[cap];
	}
 
    // destructor
    ~ordered_array() { delete []pointer; }

    /* size()
       Returns the size (number of elements in the array).
    */

    int size() { return size2;}


    /* capacity()
       Returns the maximum size of the array.
    */

    int capacity() { return capac;}
	
    /* insert(e)
       Insert e into the array. Note that it is OK to insert duplicates; if n 
       copies of a value are inserted into the array then n copies should appear
       in the array.

       If size() == capacity() then this does nothing.

       If e == -2147483648 then this does nothing (i.e., -2147483648 is not a
       valid value to insert).
    */

    void insert(int elem) 
	{
 	    // if (size() != capacity())
        {
           for (int i = 0; i<size2; i++)
          {
	       pointer[i] = elem;
	        
            // for (int j = size2; j > i; j--)
            //    { pointer[j] = pointer[j-1];
            //      pointer[i] = elem;
            //      size2++;
            //      }
             // pointer[size2] = elem;   
             // cout <<pointer[size2];      
             // }
            }
         }
     }      

    /* remove(e)
       Remove e from the array, if it exists. (If it does not exist, the
       array should be unchanged.) If multiple copies of e are present, only
       one should be removed.

       If e = -2147483648 then this does nothing.
    */
   
    void remove(int elem)
    {
      if (size2 == elem)	 
        { for (int i = 0; i<size2; i++)
        	{
             
	            {
                 for (int j = i; j < size2-1; j++)
                 {
                  pointer[j] =  pointer[j+1];
                  size2--;
                 }  
                }
             }     
             
         }
      }     



    /* exists(e)
       Returns true if e is present at least once in the array.

       If e == -2147483648 then this returns false.
    */

    bool exists(int elem)
    {
        if (size2 == 0)
        {    
          return false;
         }
        else  
        { //for(int i = 0; i<size2;  i++)
	      //{
          // if (pointer[i] == elem)
	       //	 {
             return true;
          //   }  
          // }
         }
     }
    /* at(i)
       Returns the value in the array at index i, which should be >= 0 and <
       size(). 

       If i < 0 or i >= size(), then at(i) should throw a std::out_of_range
       exception. (This is what std::vector does in this situation.)

       Note that at() should *never* return -2147483648 (because insert() should
       never insert it).
    */

    int at(int i)
	{
    	if( i<0 || i >= size2 )
		{
		throw std::out_of_range("std::out_of_range");
         return pointer[i];
		}
		
     	else
       {
        	for(i=0; i<size2; i++)
        	{
    	    return pointer[i];
         	}

          }	
       
       }

  private:
	int capac;
	int size2;
	int *pointer;

};
*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Tue Feb 11 23:04:31 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
assign1_test.cpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Tue Feb 11 23:04:31 2020
*** JOE was aborted by UNIX signal 15

*** File 'ordered_array.hpp'
#include <stdexcept> // For out_of_range
#include <iostream>

class ordered_array {
  public:
    /* constructor
       Construct a new ordered_array with the given capacity (maximum size).
       The size of a new ordered_array should be 0.
    */

    ordered_array(int cap) 
	{ 
//	pointer = new int[cap];
	capac = cap;
	size2 =0;
	pointer = new int[cap];
	}
 
    // destructor
    ~ordered_array() { delete []pointer; }

    /* size()
       Returns the size (number of elements in the array).
    */

    int size() { return size2;}


    /* capacity()
       Returns the maximum size of the array.
    */

    int capacity() { return capac;}
	
    /* insert(e)
       Insert e into the array. Note that it is OK to insert duplicates; if n 
       copies of a value are inserted into the array then n copies should appear
       in the array.

       If size() == capacity() then this does nothing.

       If e == -2147483648 then this does nothing (i.e., -2147483648 is not a
       valid value to insert).
    */

    void insert(int elem) 
	{
 	    // if (size() != capacity())
        {
           for (int i = 0; i<size2; i++)
          {
	       pointer[i] = elem;
	        
            // for (int j = size2; j > i; j--)
            //    { pointer[j] = pointer[j-1];
            //      pointer[i] = elem;
            //      size2++;
            //      }
             // pointer[size2] = elem;   
             // cout <<pointer[size2];      
             // }
            }
         }
     }      

    /* remove(e)
       Remove e from the array, if it exists. (If it does not exist, the
       array should be unchanged.) If multiple copies of e are present, only
       one should be removed.

       If e = -2147483648 then this does nothing.
    */
   
    void remove(int elem)
    {

              if (pointer[i] == elem)
	            {
                 for (int = i; j < size2-1; j++)
                 {
                  pointer[j] =  pointer[j+1];
                  size2--;
                 }  
                }
             }     
             
         }
      }     



    /* exists(e)
       Returns true if e is present at least once in the array.

       If e == -2147483648 then this returns false.
    */

    bool exists(int elem)
    {
        if (size2 == 0)
        {    
          return false;
         }
        else  
        { //for(int i = 0; i<size2;  i++)
	      //{
          // if (pointer[i] == elem)
	       //	 {
             return true;
          //   }  
          // }
         }
     }
    /* at(i)
       Returns the value in the array at index i, which should be >= 0 and <
       size(). 

       If i < 0 or i >= size(), then at(i) should throw a std::out_of_range
       exception. (This is what std::vector does in this situation.)

       Note that at() should *never* return -2147483648 (because insert() should
       never insert it).
    */

    int at(int i)
	{
    	if( i<0 || i >= size2 )
		{
		throw std::out_of_range("std::out_of_range");
         return pointer[i];
		}
		
     	else
       {
        	for(i=0; i<size2; i++)
        	{
    	    return pointer[i];
         	}

          }	
       
       }

  private:
	int capac;
	int size2;
	int *pointer;

};
*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Tue Feb 11 23:04:31 2020
*** JOE was aborted by UNIX signal 15

*** File 'ordered_array.hpp'
#include <stdexcept> // For out_of_range
#include <iostream>

class ordered_array {
  public:
    /* constructor
       Construct a new ordered_array with the given capacity (maximum size).
       The size of a new ordered_array should be 0.
    */

    ordered_array(int cap) 
	{ 
//	pointer = new int[cap];
	capac = cap;
	size2 =0;
	pointer = new int[cap];
	}
 
    // destructor
    ~ordered_array() { delete []pointer; }

    /* size()
       Returns the size (number of elements in the array).
    */

    int size() { return size2;}


    /* capacity()
       Returns the maximum size of the array.
    */

    int capacity() { return capac;}
	
    /* insert(e)
       Insert e into the array. Note that it is OK to insert duplicates; if n 
       copies of a value are inserted into the array then n copies should appear
       in the array.

       If size() == capacity() then this does nothing.

       If e == -2147483648 then this does nothing (i.e., -2147483648 is not a
       valid value to insert).
    */

    void insert(int elem) 
	{
 	    if (size() != capacity())
        {
           for (int i = 0; i<size2; i++)
          {
	       pointer[i] = elem;
	        
            // for (int j = size2; j > i; j--)
            //    { pointer[j] = pointer[j-1];
            //      pointer[i] = elem;
            //      size2++;
            //      }
             // pointer[size2] = elem;   
             // cout <<pointer[size2];      
             // }
            }
         }
     }      

    /* remove(e)
       Remove e from the array, if it exists. (If it does not exist, the
       array should be unchanged.) If multiple copies of e are present, only
       one should be removed.

       If e = -2147483648 then this does nothing.
    */
   
    void remove(int elem)
    {
     
         for (int i = 0; i<size2; i++)
        	{
              if (pointer[i] == elem)
	            {
                 for (int j = i; j < size2-1; j++)
                 {
                  pointer[j] =  pointer[j+1];
                  size2--;
                 }  
                }
             }     
      }     



    /* exists(e)
       Returns true if e is present at least once in the array.

       If e == -2147483648 then this returns false.
    */

    bool exists(int elem)
    {
        if (size2 != 0)
        {
        for(int i = 0; i<size2;  i++)
	     {
          if (pointer[i] == elem)
	      	 {
             return true;

             }  
            else{ return false;}         
           }
         }
                 
     
     
     
     }
     
    /* at(i)
       Returns the value in the array at index i, which should be >= 0 and <
       size(). 

       If i < 0 or i >= size(), then at(i) should throw a std::out_of_range
       exception. (This is what std::vector does in this situation.)

       Note that at() should *never* return -2147483648 (because insert() should
       never insert it).
    */

    int at(int i)
	{
    	if( i<0 || i >= size2 )
		{
		throw std::out_of_range("std::out_of_range");
         return pointer[i];
		}
		
     	else
       {
        	for(i=0; i<size2; i++)
        	{
    	    return pointer[i];
         	}

          }	
       
       }

  private:
	int capac;
	int size2;
	int *pointer;

};
*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Wed Feb 12 00:04:28 2020
*** JOE was aborted by UNIX signal 15

*** File 'ordered_array.hpp'
#include <stdexcept> // For out_of_range
#include <iostream>
//#include "assign1_test.cpp"

class ordered_array {
  public:
    /* constructor
       Construct a new ordered_array with the given capacity (maximum size).
       The size of a new ordered_array should be 0.
    */

    ordered_array(int cap) 
	{ 
	pointer = new int[cap];
	capac = cap;
	size2 =0;
	}
 
    // destructor
    ~ordered_array() { delete []pointer; }

    /* size()
       Returns the size (number of elements in the array).
    */

    int size() { return size2;}


    /* capacity()
       Returns the maximum size of the array.
    */

    int capacity() { return capac;}
	
    /* insert(e)
       Insert e into the array. Note that it is OK to insert duplicates; if n 
       copies of a value are inserted into the array then n copies should appear
       in the array.

       If size() == capacity() then this does nothing.

       If e == -2147483648 then this does nothing (i.e., -2147483648 is not a
       valid value to insert).
    */

    void insert(int elem) 
	{
 	     if ( size2 < capac)
        {
           for (int i = 0; i<size2; i++)
          {
	       if (pointer[i] > elem)
	         {
              for (int j = size2; j > i; j--)
                 { pointer[j] = pointer[j-1];
                   pointer[i] = elem;
                   size2++;
                   }
               pointer[size2] = elem;         
              }
            }
         }
     }      

    /* remove(e)
       Remove e from the array, if it exists. (If it does not exist, the
       array should be unchanged.) If multiple copies of e are present, only
       one should be removed.

       If e = -2147483648 then this does nothing.
    */
   
    void remove(int elem)
    {
      if (size2 != 0)	 
        { for (int i = 0; i<size2; i++)
        	{
              if (pointer[i] == elem)
	            {
                 for (int j = i; j < size2-1; j++)
                 {
                  pointer[j] =  pointer[j+1];
                  size2--;
                 }  
                }
             }     
             
         }
      }     



    /* exists(e)
       Returns true if e is present at least once in the array.

       If e == -2147483648 then this returns false.
    */

    bool exists(int elem)
    {
        if (size2 == 0)
        {    
          return false;
         }
        else  
        { for(int i = 0; i<size2;  i++)
	      {
           if (pointer[i] == elem)
	       	 {
             return true;
             }  
           }
         }
     }
    /* at(i)
       Returns the value in the array at index i, which should be >= 0 and <
       size(). 

       If i < 0 or i >= size(), then at(i) should throw a std::out_of_range
       exception. (This is what std::vector does in this situation.)

       Note that at() should *never* return -2147483648 (because insert() should
       never insert it).
    */

    int at(int i)
	{
    	if( i<0 || i >= size2 )
		{
		throw out_of_range/* at(i)
       Returns the value in the array at index i, which should be >= 0 and <
       size(). 

       If i < 0 or i >= size(), then at(i) should throw a std::out_of_range
       exception. (This is what std::vector does in this situation.)

       Note that at() should *never* return -2147483648 (because insert() should
       never insert it).
    */
    int at(int i);

//		return std::out_of_range;
return 0;
		}
		
     	else
       {
        	for(i=0; i<size2; i++)
        	{
    	    return pointer[i];
         	}

          }	
       
       }

  private:
	int capac;
	int size2;
	int *pointer;

};
*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Wed Feb 12 00:04:28 2020
*** JOE was aborted by UNIX signal 15

*** File 'ordered_array.hpp'
#include <stdexcept> // For out_of_range
#include <iostream>
//#include "assign1_test.cpp"

class ordered_array {
  public:
    /* constructor
       Construct a new ordered_array with the given capacity (maximum size).
       The size of a new ordered_array should be 0.
    */

    ordered_array(int cap) 
	{ 
	pointer = new int[cap];
	capac = cap;
	size2 =0;
	}
 
    // destructor
    ~ordered_array() { delete []pointer; }

    /* size()
       Returns the size (number of elements in the array).
    */

    int size() { return size2;}


    /* capacity()
       Returns the maximum size of the array.
    */

    int capacity() { return capac;}
	
    /* insert(e)
       Insert e into the array. Note that it is OK to insert duplicates; if n 
       copies of a value are inserted into the array then n copies should appear
       in the array.

       If size() == capacity() then this does nothing.

       If e == -2147483648 then this does nothing (i.e., -2147483648 is not a
       valid value to insert).
    */

    void insert(int elem) 
	{
 	     if ( size2 < capac)
        {
           for (int i = 0; i<size2; i++)
          {
	       if (pointer[i] > elem)
	         {
              for (int j = size2; j > i; j--)
                 { pointer[j] = pointer[j-1];
                   pointer[i] = elem;
                   size2++;
                   }
               pointer[size2] = elem;         
              }
            }
         }
     }      

    /* remove(e)
       Remove e from the array, if it exists. (If it does not exist, the
       array should be unchanged.) If multiple copies of e are present, only
       one should be removed.

       If e = -2147483648 then this does nothing.
    */
   
    void remove(int elem)
    {
      if (size2 != 0)	 
        { for (int i = 0; i<size2; i++)
        	{
              if (pointer[i] == elem)
	            {
                 for (int j = i; j < size2-1; j++)
                 {
                  pointer[j] =  pointer[j+1];
                  size2--;
                 }  
                }
             }     
             
         }
      }     



    /* exists(e)
       Returns true if e is present at least once in the array.

       If e == -2147483648 then this returns false.
    */

    bool exists(int elem)
    {
        if (size2 == 0)
        {    
          return false;
         }
        else  
        { for(int i = 0; i<size2;  i++)
	      {
           if (pointer[i] == elem)
	       	 {
             return true;
             }  
           }
         }
     }
    /* at(i)
       Returns the value in the array at index i, which should be >= 0 and <
       size(). 

       If i < 0 or i >= size(), then at(i) should throw a std::out_of_range
       exception. (This is what std::vector does in this situation.)

       Note that at() should *never* return -2147483648 (because insert() should
       never insert it).
    */

    int at(int i)
	{
    	if( i<0 || i >= size2 )
		{
		throw std::out_of_range("std::* at(i)
       Returns the value in the array at index i, which should be >= 0 and <
       size(). 

       If i < 0 or i >= size(), then at(i) should throw a std::out_of_range
       exception. (This is what std::vector does in this situation.)

       Note that at() should *never* return -2147483648 (because insert() should
       never insert it).
    */
    int at(int i);
out_of_range");
         return pointer[i];
		}
		
     	else
       {
        	for(i=0; i<size2; i++)
        	{
    	    return pointer[i];
         	}

          }	
       
       }

  private:
	int capac;
	int size2;
	int *pointer;

};
*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Wed Feb 12 00:04:28 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Wed Feb 12 01:12:34 2020
*** JOE was aborted by UNIX signal 15

*** File 'ordered_array.hpp'
#include <stdexcept> // For out_of_range
#include <iostream>

class ordered_array {
  public:
    /* constructor
       Construct a new ordered_array with the given capacity (maximum size).
       The size of a new ordered_array should be 0.
    */

    ordered_array(int cap) 
	{ 
	pointer = new int[cap];
	capac = cap;
	size2 =0;
	}
 
    // destructor
    ~ordered_array() { delete []pointer; }

    /* size()
       Returns the size (number of elements in the array).
    */

    int size() { return size2;}


    /* capacity()
       Returns the maximum size of the array.
    */

    int capacity() { return capac;}
	
    /* insert(e)
       Insert e into the array. Note that it is OK to insert duplicates; if n 
       copies of a value are inserted into the array then n copies should appear
       in the array.

       If size() == capacity() then this does nothing.

       If e == -2147483648 then this does nothing (i.e., -2147483648 is not a
       valid value to insert).
    */

    void insert(int elem) 
	{
 	   if(size() != capacity())       
 	    {     
             if(size2 == 0)
            {
              for (int i=0; i<capac; i++)
              {
	          pointer[i] = elem;
	          break;
	          }
            size2++;	        
	        } 
	         else if (size2 !=0)
	         {
	         pointer[size2+1] = elem;
	         size2++;
	          }      
         }            
     }      

    /* remove(e)
       Remove e from the array, if it exists. (If it does not exist, the
       array should be unchanged.) If multiple copies of e are present, only
       one should be removed.

       If e = -2147483648 then this does nothing.
    */
   
    void remove(int elem)
    {
        if(size2 !=0)
        {     
         for (int i = 0; i<size2; i++)
        	{
              if (pointer[i] == elem)
                 {            
                 pointer[i] = pointer[i-1]; 
                    
                  }
              break;      
             }
            size2--;        
         }     
      }     
///


    /* exists(e)
       Returns true if e is present at least once in the array.

       If e == -2147483648 then this returns false.
    */

    bool exists(int elem)
    {
        if (size2 != 0)
        {
        for(int i = 0; i<size2;  i++)
	     {
          if (pointer[i] == elem)
	      	 {
             return true;

             }  
            else if (pointer[i] != elem){ return false;}         
           }
         }
                 
     
     
     
     }
     
    /* at(i)
       Returns the value in the array at index i, which should be >= 0 and <
       size(). 

       If i < 0 or i >= size(), then at(i) should throw a std::out_of_range
       exception. (This is what std::vector does in this situation.)

       Note that at() should *never* return -2147483648 (because insert() should
       never insert it).
    */

    int at(int i)
	{
     	 if (i>= 0 && i <size())
        {
        	for(i=0; i<size2; i++)
        	{
    	    return pointer[i];
         	}

         }	
       else
		{
		throw std::out_of_range("std::out_of_range");
         return pointer[i];
		}
		
     }

  private:
	int capac;
	int size2;
	int *pointer;

};
*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Wed Feb 12 01:12:34 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Wed Feb 12 01:12:34 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Wed Feb 12 01:12:34 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Wed Feb 12 11:47:23 2020
*** JOE was aborted by UNIX signal 15

*** File 'ordered_array.hpp'
#include <stdexcept> // For out_of_range
#include <iostream>

class ordered_array {
  public:
    /* constructor
       Construct a new ordered_array with the given capacity (maximum size).
       The size of a new ordered_array should be 0.
    */

    ordered_array(int cap) 
	{ 
	pointer = new int[cap];
	capac = cap;
	size2 =0;
	}
 
    // destructor
    ~ordered_array() { delete []pointer; }

    /* size()
       Returns the size (number of elements in the array).
    */

    int size() { return size2;}


    /* capacity()
       Returns the maximum size of the array.
    */

    int capacity() { return capac;}
	
    /* insert(e)
       Insert e into the array. Note that it is OK to insert duplicates; if n 
       copies of a value are inserted into the array then n copies should appear
       in the array.

       If size() == capacity() then this does nothing.

       If e == -2147483648 then this does nothing (i.e., -2147483648 is not a
       valid value to insert).
    */

    void insert(int elem) 
	{
 	   if(size() != capacity())       
 	    {     
             if(size2 == 0)
            {
              for (int i=0; i<capac; i++)
              {
	          pointer[i] = elem;
	          break;
	          }
           	  size2++;      
	        } 
	        
	         else if(size2 !=0)
	         {
	         pointer[size2] = elem;
	         size2++;
	          }      
         }            
     }      

    /* remove(e)
       Remove e from the array, if it exists. (If it does not exist, the
       array should be unchanged.) If multiple copies of e are present, only
       one should be removed.

       If e = -2147483648 then this does nothing.
    */
   
    void remove(int elem)
    {
        if(size2 !=0)
        {     
         for (int i = 0; i<size2; i++)
        	{
              if (pointer[i] == elem)
                 {            
                 pointer[i] = pointer[i-1]; 
                size2--;                   
                 break;   
                  }
             
             }
                    
         }     
      }     
///


    /* exists(e)
       Returns true if e is present at least once in the array.

       If e == -2147483648 then this returns false.
    */

    bool exists(int elem)
    {
        for(int i = 0; i<size();  i++)
	     {
          if (pointer[i] == elem)
	      	 {
             return true;

             }  
            else if (pointer[i] != elem)
             { return false;}         
           }
     }
                 
    
     
    /* at(i)
       Returns the value in the array at index i, which should be >= 0 and <
       size(). 

       If i < 0 or i >= size(), then at(i) should throw a std::out_of_range
       exception. (This is what std::vector does in this situation.)

       Note that at() should *never* return -2147483648 (because insert() should
       never insert it).
    */

    int at(int i)
	{
     	 if (i>= 0 && i <size())
        {
        	for(i=0; i<size2; i++)
        	{
    	    return pointer[i];
         	}

         }	
       else
		{
		throw std::out_of_range("std::out_of_range");
         return pointer[i];
		}
		
     }

  private:
	int capac;
	int size2;
	int *pointer;

};
*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Thu Feb 13 19:37:01 2020
*** JOE was aborted by UNIX signal 1

*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
orderd_array.hpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Thu Feb 13 19:37:01 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Thu Feb 13 19:37:01 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
assign1_test.cpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Thu Feb 13 19:37:01 2020
*** JOE was aborted by UNIX signal 1

*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordere_array.hpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Thu Feb 13 19:37:01 2020
*** JOE was aborted by UNIX signal 1

*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Thu Feb 13 19:37:01 2020
*** JOE was aborted by UNIX signal 1

*** File '(Unnamed)'

*** These modified files were found in JOE when it aborted on Thu Feb 13 19:37:01 2020
*** JOE was aborted by UNIX signal 15
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp

*** File '(Unnamed)'

*** File '* Startup Log *'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Thu Feb 13 19:37:01 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Thu Feb 13 19:37:01 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.cpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Thu Feb 13 19:37:01 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
assign1_test.cpp
ordered_array.hpp
assign1_test.cpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Thu Feb 13 19:37:01 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
assign1_test.cpp
ordered_array.hpp
assign1_test.cpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Thu Feb 13 19:37:01 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
assign1_test.cpp
ordered_array.hpp
ordered_array.hpp
assign1_test.cpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Thu Feb 13 19:37:01 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
assign1_test.cpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Thu Feb 13 19:37:01 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
assign1_test.cpp
ordered_array.hpp
ordered_array.hpp
assign1_test.cpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Thu Feb 13 19:37:01 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
assign1_test.cpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
assign1_test.cpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Thu Feb 13 19:37:01 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
assign1_test.cpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Thu Feb 13 19:37:01 2020
*** JOE was aborted by UNIX signal 15

*** File 'ordered_array.hpp'
#include <stdexcept> // For out_of_range
#include <iostream>

class ordered_array {
  public:
    /* constructor
       Construct a new ordered_array with the given capacity (maximum size).
       The size of a new ordered_array should be 0.
    */

    ordered_array(int cap) 
	{ 
	pointer = new int[cap];
	capac = cap;
	size2 =0;

	
	}
	
	ordered_array(const ordered_array& other) 
	{ 
	
	capac = other.capac;
	size2 =other.size2;
       pointer = new int[capac];
	
	for(int i = 0; i < size2; ++i)
      pointer[i] = other.pointer[i];

	}


 
    // destructor
    ~ordered_array() { delete []pointer; }

    /* size()
       Returns the size (number of elements in the array).
    */

    int size() { return size2;}


    /* capacity()
       Returns the maximum size of the array.
    */

    int capacity() { return capac;}
	
    /* insert(e)
       Insert e into the array. Note that it is OK to insert duplicates; if n 
       copies of a value are inserted into the array then n copies should appear
       in the array.

       If size() == capacity() then this does nothing.

       If e == -2147483648 then this does nothing (i.e., -2147483648 is not a
       valid value to insert).
    */

    void insert(int elem)
     {
      if(size() != capacity())       
      {  
        if (elem != -2147483648)
       	{	   
        	if( size()==0)
        	{
        	   pointer[size2]=elem;
        	 size2++;
        	 }
        	 
        	 else{   
            for (int i=size(); i<=size(); i++)
                {
	          pointer[size2] = elem;
	          break;
	          }     
           	  size2++;    
           	 } 
         }  
        }
       }      
	

    /* remove(e)
       Remove e from the array, if it exists. (If it does not exist, the
       array should be unchanged.) If multiple copies of e are present, only
       one should be removed.

       If e = -2147483648 then this does nothing.
    */
   
    void remove(int elem)
    {
     if(size() !=0)
     {           
      for (int i =0; i<=size(); i++)
      {
       if (pointer[i] == elem)
        { 
         for (int j =0; j<=size(); j++ )
         { 
         if( pointer[j] !=elem)
          {          
           std::swap(pointer[i], pointer[j]);                   
           size2--; 
	         
           }
          break;   
         }         
        }     
  break;
      }     
     }    
    }


    /* exists(e)
       Returns true if e is present at least once in the array.
              If e == -2147483648 then this returns false.
    */

    bool exists(int elem)
    {         
        for(int i = 0; i<=size();  i++)
	     {
          if (pointer[i] == elem)
	      	 {
             return true;
             }
          } 
		 if(elem == -2147483648)
           	{return false;}
         else return false;  	
    }                 
    
     
    /* at(i)
       Returns the value in the array at index i, which should be >= 0 and <
       size(). 

       If i < 0 or i >= size(), then at(i) should throw a std::out_of_range
       exception. (This is what std::vector does in this situation.)

       Note that at() should *never* return -2147483648 (because insert() should
       never insert it).
    */

    int at(int i)
	{
     	
       if (i<0 || i >= size())
      	{
		throw std::out_of_range("std::out_of_range");
//         return pointer[i];
		}
		else
        {
        	for(i=0; i<size(); i++) { return pointer[i]; break; }
     }

  private:
	int capac;
	int size2;
	int *pointer;

};
*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
assign1_test.cpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Thu Feb 13 19:37:01 2020
*** JOE was aborted by UNIX signal 15

*** File 'ordered_array.hpp'
#include <stdexcept> // For out_of_range
#include <iostream>

class ordered_array {
  public:
    /* constructor
       Construct a new ordered_array with the given capacity (maximum size).
       The size of a new ordered_array should be 0.
    */

    ordered_array(int cap) 
	{ 
	pointer = new int[cap];
	capac = cap;
	size2 =0;

	
	}
	
	ordered_array(const ordered_array& other) 
	{ 
	
	capac = other.capac;
	size2 =other.size2;
       pointer = new int[capac];
	
	for(int i = 0; i < size2; ++i)
      pointer[i] = other.pointer[i];

	}


 
    // destructor
    ~ordered_array() { delete []pointer; }

    /* size()
       Returns the size (number of elements in the array).
    */

    int size() { return size2;}


    /* capacity()
       Returns the maximum size of the array.
    */

    int capacity() { return capac;}
	
    /* insert(e)
       Insert e into the array. Note that it is OK to insert duplicates; if n 
       copies of a value are inserted into the array then n copies should appear
       in the array.

       If size() == capacity() then this does nothing.

       If e == -2147483648 then this does nothing (i.e., -2147483648 is not a
       valid value to insert).
    */

    void insert(int elem)
     {
      if(size() != capacity())       
      {  
        if (elem != -2147483648)
       	{	   
        	if( size()==0)
        	{
        	   pointer[size2]=elem;
        	 size2++;
        	 }
        	 
        	 else{   
            for (int i=size(); i<=size(); i++)
                {
	          pointer[size2] = elem;
	          break;
	          }     
           	  size2++;    
           	 } 
         }  
        }
       }      
	

    /* remove(e)
       Remove e from the array, if it exists. (If it does not exist, the
       array should be unchanged.) If multiple copies of e are present, only
       one should be removed.

       If e = -2147483648 then this does nothing.
    */
   
    void remove(int elem)
    {
     if(size() !=0)
     {           
      for (int i =0; i<=size(); i++)
      {
       if (pointer[i] == elem)
        { 
         for (int j =0; j<=size(); j++ )
         { 
         if( pointer[j] !=elem)
          {          
           std::swap(pointer[i], pointer[j]);                   
           size2--; 
	         
           }
          break;   
         }         
        }     
  break;
      }     
     }    
    }


    /* exists(e)
       Returns true if e is present at least once in the array.
              If e == -2147483648 then this returns false.
    */

    bool exists(int elem)
    {         
        for(int i = 0; i<=size();  i++)
	     {
          if (pointer[i] == elem)
	      	 {
             return true;
             }
          } 
		 if(elem == -2147483648)
           	{return false;}
         else return false;  	
    }                 
    
     
    /* at(i)
       Returns the value in the array at index i, which should be >= 0 and <
       size(). 

       If i < 0 or i >= size(), then at(i) should throw a std::out_of_range
       exception. (This is what std::vector does in this situation.)

       Note that at() should *never* return -2147483648 (because insert() should
       never insert it).
    */

    int at(int i)
	{
     	
       if (i<0 || i >= size())
      	{
		throw std::out_of_range("std::out_of_range");
//         return pointer[i];
		}
		else
        {
        	for(i=0; i<size(); i++)
        	{
    	     return  pointer[i];
                   
           	}
                    
         }
           	
     }

  private:
	int capac;
	int size2;
	int *pointer;

};
*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
assign1_test.cpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Thu Feb 13 20:09:58 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
assign1_test.cpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Thu Feb 13 20:09:58 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
assign1_test.cpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Thu Feb 13 20:09:58 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
assign1_test.cpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
assign1_test.cpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Thu Feb 13 20:09:58 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
assign1_test.cpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Thu Feb 13 20:09:58 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
ordered_array.hpp
assign1_test.cpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
assign1_test.cpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Thu Feb 13 20:09:58 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
assign1_test.cpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Thu Feb 13 20:09:58 2020
*** JOE was aborted by UNIX signal 15

*** File 'ordered_array.hpp'
#include <stdexcept> // For out_of_range
#include <iostream>

class ordered_array {
  public:
    /* constructor
       Construct a new ordered_array with the given capacity (maximum size).
       The size of a new ordered_array should be 0.
    */

    ordered_array(int cap) 
	{ 
	pointer = new int[cap];
	capac = cap;
	size2 =0;

	
	}
	
	ordered_array(const ordered_array& other) 
	{ 
	
	capac = other.capac;
	size2 =other.size2;
       pointer = new int[capac];
	
	for(int i = 0; i < size2; ++i)
      pointer[i] = other.pointer[i];

	}


 
    // destructor
    ~ordered_array() { delete []pointer; }

    /* size()
       Returns the size (number of elements in the array).
    */

    int size() { return size2;}


    /* capacity()
       Returns the maximum size of the array.
    */

    int capacity() { return capac;}
	
    /* insert(e)
       Insert e into the array. Note that it is OK to insert duplicates; if n 
       copies of a value are inserted into the array then n copies should appear
       in the array.

       If size() == capacity() then this does nothing.

       If e == -2147483648 then this does nothing (i.e., -2147483648 is not a
       valid value to insert).
    */

    void insert(int elem)
     {
      if(size() != capacity())       
      {  
        if (elem != -2147483648)
       	{	   
        	if( size()==0)
        	{
        	   pointer[size()]=elem;
        	 size2++;
        	 }
        	 
        	 else{   
            //for (int i=size(); i<=size(); i++)
             //   {
	          pointer[size2++] = elem;
	         // break;
	         // }     
           	 // size2++;    
           	 } 
         }  
        }
       }      
	

    /* remove(e)
       Remove e from the array, if it exists. (If it does not exist, the
       array should be unchanged.) If multiple copies of e are present, only
       one should be removed.

       If e = -2147483648 then this does nothing.
    */
   
    void remove(int elem)
    {
     if(size() !=0)
     {           
      for (int i =0; i<=size(); i++)
      {
       if (pointer[i] == elem)
        { 
         for (int j =0; j<=size(); j++ )
         { 
         if( pointer[j] !=elem)
          {          
           std::swap(pointer[i], pointer[j]);                   
           size2--; 
	         
           }
          break;   
         }         
        }     
  break;
      }     
     }    
    }


    /* exists(e)
       Returns true if e is present at least once in the array.
              If e == -2147483648 then this returns false.
    */

    bool exists(int elem)
    {         
        for(int i = 0; i<=size();  i++)
	     {
          if (pointer[i] == elem)
	      	 {
             return true;
             }
          } 
		 if(elem == -2147483648)
           	{return false;}
         else return false;  	
    }                 
    
     
    /* at(i)
       Returns the value in the array at index i, which should be >= 0 and <
       size(). 

       If i < 0 or i >= size(), then at(i) should throw a std::out_of_range
       exception. (This is what std::vector does in this situation.)

       Note that at() should *never* return -2147483648 (because insert() should
       never insert it).
    */

    int at(int i)
	{
     	int value;
       if (i<0 || i >= size())
      	{
		throw std::out_of_range("std::out_of_range");
		}
		else
        {
        	for(i=0; i<size(); i++)
        	{
    	    value= pointer[i];
           // return value;           
             break;       
           	}
           	
          return value;
         }  
     }

  private:
	int capac;
	int size2;
	int *pointer;

};
*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Thu Feb 13 20:09:58 2020
*** JOE was aborted by UNIX signal 15

*** File 'ordered_array.hpp'
#include <stdexcept> // For out_of_range
#include <iostream>

class ordered_array {
  public:
    /* constructor
       Construct a new ordered_array with the given capacity (maximum size).
       The size of a new ordered_array should be 0.
    */

    ordered_array(int cap) 
	{ 
	pointer = new int[cap];
	capac = cap;
	size2 =0;

	
	}
	
	ordered_array(const ordered_array& other) 
	{ 
	
	capac = other.capac;
	size2 =other.size2;
       pointer = new int[capac];
	
	for(int i = 0; i < size2; ++i)
      pointer[i] = other.pointer[i];

	}


 
    // destructor
    ~ordered_array() { delete []pointer; }

    /* size()
       Returns the size (number of elements in the array).
    */

    int size() { return size2;}


    /* capacity()
       Returns the maximum size of the array.
    */

    int capacity() { return capac;}
	
    /* insert(e)
       Insert e into the array. Note that it is OK to insert duplicates; if n 
       copies of a value are inserted into the array then n copies should appear
       in the array.

       If size() == capacity() then this does nothing.

       If e == -2147483648 then this does nothing (i.e., -2147483648 is not a
       valid value to insert).
    */

    void insert(int elem)
     {
      if(size() != capacity())       
      {  
        if (elem != -2147483648)
       	{	   
        	if( size()==0)
        	{
        	   pointer[size2]=elem;
        	 size2++;
        	 }
        	 
        	 else{   
            for (int i=size(); i<=size(); i++)
                {
	          pointer[size2] = elem;
	          break;
	          }     
           	  size2++;    
           	 } 
         }  
        }
       }      
	

    /* remove(e)
       Remove e from the array, if it exists. (If it does not exist, the
       array should be unchanged.) If multiple copies of e are present, only
       one should be removed.

       If e = -2147483648 then this does nothing.
    */
   
    void remove(int elem)
    {
     if(size() !=0)
     {           
      for (int i =0; i<=size(); i++)
      {
       if (pointer[i] == elem)
        { 
         for (int j =0; j<=size(); j++ )
         { 
         if( pointer[j] !=elem)
          {          
           std::swap(pointer[i], pointer[j]);                   
           size2--; 
	         
           }
          break;   
         }         
        }     
  break;
      }     
     }    
    }


    /* exists(e)
       Returns true if e is present at least once in the array.
              If e == -2147483648 then this returns false.
    */

    bool exists(int elem)
    {         
        for(int i = 0; i<=size();  i++)
	     {
          if (pointer[i] == elem)
	      	 {
             return true;
             }
          } 
		 if(elem == -2147483648)
           	{return false;}
         else return false;  	
    }                 
    
     
    /* at(i)
       Returns the value in the array at index i, which should be >= 0 and <
       size(). 

       If i < 0 or i >= size(), then at(i) should throw a std::out_of_range
       exception. (This is what std::vector does in this situation.)

       Note that at() should *never* return -2147483648 (because insert() should
       never insert it).
    */

    int at(int i)
	{
     	int value;
       if (i<0 || i >= size())
      	{
		throw std::out_of_range("std::out_of_range");
//         return pointer[i];
		}
		else
        {
        	for(i=0; i<size(); i++)
        	{
    	    value= pointer[i];
           // return value;           

             break;       
           	}
        return value;
         }  
     }

  private:
	int capac;
	int size2;
	int *pointer;

};
*** File '(Unnamed)'
ordered_array.hpp
assign1_test.cpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Thu Feb 13 20:09:58 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
ordered_array.hpp
assign1_test.cpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Thu Feb 13 20:15:28 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Thu Feb 13 20:15:28 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Fri Feb 14 01:00:01 2020
*** JOE was aborted by UNIX signal 15

*** File 'ordered_array.hpp'
#include <stdexcept> // For out_of_range
#include <iostream>

class ordered_array {
  public:
    /* constructor
       Construct a new ordered_array with the given capacity (maximum size).
       The size of a new ordered_array should be 0.
    */

    ordered_array(int cap) 
	{ 
	pointer = new int[cap];
	capac = cap;
	size2 =0;

	
	}
	
	ordered_array(const ordered_array& other) 
	{ 
	
	capac = other.capac;
	size2 =other.size2;
       pointer = new int[capac];
	
	for(int i = 0; i < size2; ++i)
      pointer[i] = other.pointer[i];

	}


 
    // destructor
    ~ordered_array() { delete []pointer; }

    /* size()
       Returns the size (number of elements in the array).
    */

    int size() { return size2;}


    /* capacity()
       Returns the maximum size of the array.
    */

    int capacity() { return capac;}
	
    /* insert(e)
       Insert e into the array. Note that it is OK to insert duplicates; if n 
       copies of a value are inserted into the array then n copies should appear
       in the array.

       If size() == capacity() then this does nothing.

       If e == -2147483648 then this does nothing (i.e., -2147483648 is not a
       valid value to insert).
    */

    void insert(int elem)
     {
      if(size() != capacity())       
      {  
        if (elem != -2147483648)
       	{	   
        	if( size()==0)
        	{
        	   pointer[size2]=elem;
        	size2++;
        	 }
        	 
        	 else{   
            //for (int i=size(); i<=size(); i++)
               // {
	          pointer[size2] = elem;
	          size2++;
	         // break;
	          //}     
           	  //size2++;    
           	 } 
         }  
        }
       }      
	

    /* remove(e)
       Remove e from the array, if it exists. (If it does not exist, the
       array should be unchanged.) If multiple copies of e are present, only
       one should be removed.

       If e = -2147483648 then this does nothing.
    */
   
    void remove(int elem)
    {
     if(size() !=0)
     {           
      for (int i =0; i<=size(); i++)
      {
       if (pointer[i] == elem)
        { 
         for (int j =0; j<=size(); j++ )
         { 
         if( pointer[j] !=elem)
          {          
           std::swap(pointer[i], pointer[j]);                   
           size2--; 
	         
           }
          break;   
         }         
        }     
  break;
      }     
     }    
    }


    /* exists(e)
       Returns true if e is present at least once in the array.
              If e == -2147483648 then this returns false.
    */

    bool exists(int elem)
    {         
        for(int i = 0; i<=size();  i++)
	     {
          if (pointer[i] == elem)
	      	 {
             return true;
             }
          } 
		 if(elem == -2147483648)
           	{return false;}
         else return false;  	
    }                 
    
     
    /* at(i)
       Returns the value in the array at index i, which should be >= 0 and <
       size(). 

       If i < 0 or i >= size(), then at(i) should throw a std::out_of_range
       exception. (This is what std::vector does in this situation.)

       Note that at() should *never* return -2147483648 (because insert() should
       never insert it).
    */

    int at(int i)
	{
     
       if (i<0 || i >= size())
      	{
		throw std::out_of_range("std::out_of_range");
		}





		else

        {
        	if(i>=0 && i<size())
        	{
                for(i=0; i<size(); i++)
                {    	
            	    if(pointer[i]>pointer[i+1])
                    { std:: swap( pointer[i],pointer[i+1]);}
            	}     
    	    return pointer[i];
           // return value;           
           //  break;       
           	}
           	
          
         }  
     }

  private:
	int capac;
	int size2;
	int *pointer;

};
*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
assign1_test.cpp
ordered_array.hpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Fri Feb 14 01:00:01 2020
*** JOE was aborted by UNIX signal 1

*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
assign1_test.cpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Fri Feb 14 12:44:32 2020
*** JOE was aborted because the terminal closed

*** File '(Unnamed)'
ordered_array.hpp
assign1_test.cpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Fri Feb 14 12:44:32 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
ordered_array.hpp
assign1_test.cpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Fri Feb 14 12:56:23 2020
*** JOE was aborted because the terminal closed

*** File '(Unnamed)'
ordered_array.hpp
assign1_test.cpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
assign1_test.cpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Fri Feb 14 12:56:23 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
assign1_test.cpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
assign1_test.cpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Fri Feb 14 12:56:23 2020
*** JOE was aborted by UNIX signal 15

*** File 'ordered_array.hpp'
#include <stdexcept> // For out_of_range
#include <iostream>

class ordered_array {
  public:
    /* constructor
       Construct a new ordered_array with the given capacity (maximum size).
       The size of a new ordered_array should be 0.
    */

    ordered_array(int cap) 
	{ 
	pointer = new int[cap];
	capac = cap;
	size2 =0;

	
	}
	
	ordered_array(const ordered_array& other) 
	{ 
	
	capac = other.capac;
	size2 =other.size2;
       pointer = new int[capac];
	
	for(int i = 0; i < size2; ++i)
      pointer[i] = other.pointer[i];

	}


 
    // destructor
    ~ordered_array() { delete []pointer; }

    /* size()
       Returns the size (number of elements in the array).
    */

    int size() { return size2;}


    /* capacity()
       Returns the maximum size of the array.
    */

    int capacity() { return capac;}
	
    /* insert(e)
       Insert e into the array. Note that it is OK to insert duplicates; if n 
       copies of a value are inserted into the array then n copies should appear
       in the array.

       If size() == capacity() then this does nothing.

       If e == -2147483648 then this does nothing (i.e., -2147483648 is not a
       valid value to insert).
    */

    void insert(int elem)
     {
      if(size() != capacity())       
      {  
        if (elem != -2147483648)
       	{	   
        	if( size()==0)
        	{
        	   pointer[size2]=elem;
        	size2++;
        	 }
        	 
        	 else{   
            //for (int i=size(); i<=size(); i++)
               // {
	          pointer[size2] = elem;
	          size2++;
	         // break;
	          //}     
           	  //size2++;    
           	 } 
         }  
        }
       }      
	

    /* remove(e)
       Remove e from the array, if it exists. (If it does not exist, the
       array should be unchanged.) If multiple copies of e are present, only
       one should be removed.

       If e = -2147483648 then this does nothing.
    */
   
    void remove(int elem)
    {
     if(size() !=0)
     {           
      for (int i =0; i<=size(); i++)
      {
       if (pointer[i] == elem)
        { 
         for (int j =0; j<=size(); j++ )
         { 
         if( pointer[j] !=elem)
          {          
           std::swap(pointer[i], pointer[j]);                   
           size2--; 
	         
           }
          break;   
         }         
        }     
  break;
      }     
     }    
    }


    /* exists(e)
       Returns true if e is present at least once in the array.
              If e == -2147483648 then this returns false.
    */

    bool exists(int elem)
    {         
        for(int i = 0; i<=size();  i++)
	     {
          if (pointer[i] == elem)
	      	 {
             return true;
             }
          } 
		 if(elem == -2147483648)
           	{return false;}
         else return false;  	
    }                 
    
     
    /* at(i)
       Returns the value in the array at index i, which should be >= 0 and <
       size(). 

       If i < 0 or i >= size(), then at(i) should throw a std::out_of_range
       exception. (This is what std::vector does in this situation.)

       Note that at() should *never* return -2147483648 (because insert() should
       never insert it).
   */

      	if(i>=0 && i<size())
       	{                   	
            if(pointer[i]>pointer[i+1])
             { std:: swap( pointer[i],pointer[i+1]);}
                     	
            	    
    	    return pointer[i];
           // return value;           
           //  break;       
           	}
           	
          
         }  
        else  
      	{
		throw std::out_of_range("std::out_of_range");
		}

     }

  private:
	int capac;
	int size2;
	int *pointer;

};
*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
assign1_test.cpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Fri Feb 14 13:21:39 2020
*** JOE was aborted because the terminal closed

*** File '(Unnamed)'
ordered_array.hpp
assign1_test.cpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Fri Feb 14 13:21:39 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
ordered_array.hpp
assign1_test.cpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Sun Feb 16 02:15:48 2020
*** JOE was aborted by UNIX signal 1

*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
VectOne.cpp
assign1_test.cpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Mon Feb 17 20:31:08 2020
*** JOE was aborted by UNIX signal 1

*** File '(Unnamed)'
main.cpp
main.cpp
pushBack.cpp
pushBack.cpp
pushBack.cpp
pushBack.cpp
pushBack.cpp
pushBack.cpp
pushBack.cpp
pushBack.cpp
ordered_array.hpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Mon Feb 17 20:31:08 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
main.cpp
main.cpp
pushBack.cpp
pushBack.cpp
pushBack.cpp
pushBack.cpp
pushBack.cpp
pushBack.cpp
pushBack.cpp
pushBack.cpp
ordered_array.cpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Mon Feb 17 20:35:44 2020
*** JOE was aborted because the terminal closed

*** File 'ordered_array.hpp'
#include <stdexcept> // For out_of_range
#include <iostream>

class ordered_array {
  public:
    /* constructor
       Construct a new ordered_array with the given capacity (maximum size).
       The size of a new ordered_array should be 0.
    */

    ordered_array(int cap) 
	{ 
	pointer = new int[cap];
	capac = cap;
	size2 =0;

	
	}
	
	ordered_array(const ordered_array& other) 
	{ 
	
	capac = other.capac;
	size2 = other.size2;
       pointer = new int[capac];
	
	for(int i = 0; i < size(); ++i)
      pointer[i] = other.pointer[i];

	}


 
    // destructor
    ~ordered_array() { delete []pointer; }

    /* size()
       Returns the size (number of elements in the array).
    */

    int size() { return size2;}


    /* capacity()
       Returns the maximum size of the array.
    */

    int capacity() { return capac;}
	
    /* insert(e)
       Insert e into the array. Note that it is OK to insert duplicates; if n 
       copies of a value are inserted into the array then n copies should appear
       in the array.

       If size() == capacity() then this does nothing.

       If e == -2147483648 then this does nothing (i.e., -2147483648 is not a
       valid value to insert).
    */

    void insert(int elem)
     {
      if(size() != capacity())       
      {  
        if (elem != -2147483648)
       	{	   
        	
        	 pointer[size2]=elem;
        	size2++;
        
           	  
         }  
        }
       }      
	

    /* remove(e)
       Remove e from the array, if it exists. (If it does not exist, the
       array should be unchanged.) If multiple copies of e are present, only
       one should be removed.

       If e = -2147483648 then this does nothing.
    */
   
    void remove(int elem)
    {
     if(size() !=0)
     {           
      for (int i =0; i<size(); i++)
      {
       if (pointer[i] == elem)
        { 
         for (int j =0; j<size(); j++ )
         { 
         if( pointer[j] !=elem)
          {          
           std::swap(pointer[i], pointer[j]);                   
           size2--; 
	         
           }
          break;   
         }         
        }     
  break;
      }     
     }    
    }


    /* exists(e)
       Returns true if e is present at least once in the array.
              If e == -2147483648 then this returns false.
    */

    bool exists(int elem)
    {         
        for(int i = 0; i<size();  i++)
	     {
          if (pointer[i] == elem)
	      	 {
             return true;
             }
          } 
		 if(elem == -2147483648)
           	{return false;}
         else if (size() == 0)  {return false;}  	
    }                 
    
     
    /* at(i)
       Returns the value in the array at index i, which should be >= 0 and <
       size(). 

       If i < 0 or i >= size(), then at(i) should throw a std::out_of_range
       exception. (This is what std::vector does in this situation.)

       Note that at() should *never* return -2147483648 (because insert() should
       never insert it).
   */

      
       int at(int i)
       {
        	if(i>=0 && i<size())
        	{
                for(i=0; i<size(); i++)
                 {
                 for(j=i+1; j<size(); i++)
   	
            	 if(pointer[i]>pointer[1])
                 { std:: swap( pointer[i],pointer[i+1]);}
                 else { return pointer[i];}
                 }    	
            	    
    	    return pointer[i];
           // return value;           
           //  break;       
           	}
           	
          
           
        else  
      	{
		throw std::out_of_range("std::out_of_range");
		}

     }

  private:
	int capac;
	int size2;
	int *pointer;

};
*** File '(Unnamed)'
main.cpp
main.cpp
pushBack.cpp
pushBack.cpp
pushBack.cpp
pushBack.cpp
pushBack.cpp
pushBack.cpp
pushBack.cpp
pushBack.cpp
ordered_array.hpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Mon Feb 17 20:35:44 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
main.cpp
main.cpp
pushBack.cpp
pushBack.cpp
pushBack.cpp
pushBack.cpp
pushBack.cpp
pushBack.cpp
pushBack.cpp
pushBack.cpp
ordere_array.hpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Mon Feb 17 21:36:44 2020
*** JOE was aborted because the terminal closed

*** File 'ordered_array.hpp'
#include <stdexcept> // For out_of_range
#include <iostream>

class ordered_array {
  public:
    /* constructor
       Construct a new ordered_array with the given capacity (maximum size).
       The size of a new ordered_array should be 0.
    */

    ordered_array(int cap) 
	{ 
	pointer = new int[cap];
	capac = cap;
	size2 =0;

	
	}
	
	ordered_array(const ordered_array& other) 
	{ 
	
	capac = other.capac;
	size2 = other.size2;
       pointer = new int[capac];
	
	for(int i = 0; i < size(); ++i)
      pointer[i] = other.pointer[i];

	}


 
    // destructor
    ~ordered_array() { delete []pointer; }

    /* size()
       Returns the size (number of elements in the array).
    */

    int size() { return size2;}


    /* capacity()
       Returns the maximum size of the array.
    */

    int capacity() { return capac;}
	
    /* insert(e)
       Insert e into the array. Note that it is OK to insert duplicates; if n 
       copies of a value are inserted into the array then n copies should appear
       in the array.

       If size() == capacity() then this does nothing.

       If e == -2147483648 then this does nothing (i.e., -2147483648 is not a
       valid value to insert).
    */

    void insert(int elem)
    {
     if( size() ==0)
       {
        if (elem != -2147483648)
        {
        pointer[0]=elem;
        size2++;
         }
       }
        
      else if(size() != capacity())       
      {  
        if (elem != -2147483648)
       {	   
         for(int i=0; i<size(); i++)
         {
            if (pointer[i] > elem)
            {
              pointer[i+1] = elem;           
              {std::swap(pointer[i+1], pointer[i]);}
              	break;
             } 	  
            else if (pointer[i] <= elem)
            { pointer[i+1]= elem;     
             
             }
          }
            
            size2++;       
        }
       }      
	}

    /* remove(e)
       Remove e from the array, if it exists. (If it does not exist, the
       array should be unchanged.) If multiple copies of e are present, only
       one should be removed.

       If e = -2147483648 then this does nothing.
    */
   
    void remove(int elem) {
     if(size()!=0){           
      for(int i =0; i<size(); i++){
        if (pointer[i] == elem)
        { 
         for (int j =i; j<size()-1; j++ )
         {           
           std::swap(pointer[j], pointer[j+1]);                      
         }         
        }     

      }     
     size2--;
     }    
    }


    /* exists(e)
       Returns true if e is present at least once in the array.
              If e == -2147483648 then this returns false.
    */

    bool exists(int elem)
    { 
         if(elem == -2147483648)
           	{return false;}
         else if (size2 == 0)  {return false;}  	
        
        else{        
        for(int i = 0; i<size();  i++)
	     {
          if (pointer[i] == elem)
	      	 {
             return true;
             break;
             }
          } 
      }  	
    }                 
    
     
    /* at(i)
       Returns the value in the array at index i, which should be >= 0 and <
       size(). 

       If i < 0 or i >= size(), then at(i) should throw a std::out_of_range
       exception. (This is what std::vector does in this situation.)

       Note that at() should *never* return -2147483648 (because insert() should
       never insert it).
   */

      
       int at(int i)
       {
        	if(i>=0 && i<size())
        	{
                for(i=0; i<size(); i++)
                 {   	
            	// if(pointer[i]>pointer[i+1])
                // { std:: swap( pointer[i],pointer[i+1]);}
                   return pointer[i];
                 }    	
            	    
    	   // return pointer[i];
           // return value;           
           //  break;       
           	}
           	
          
           
        else  
      	{
		throw std::out_of_range("std::out_of_range");
		}

     }

  private:
	int capac;
	int size2;
	int *pointer;

};
*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Mon Feb 17 21:36:44 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'

*** These modified files were found in JOE when it aborted on Mon Feb 17 21:36:44 2020
*** JOE was aborted by UNIX signal 15
main.cpp
main.cpp
pushBack.cpp
pushBack.cpp
pushBack.cpp
pushBack.cpp
pushBack.cpp
pushBack.cpp
pushBack.cpp
pushBack.cpp
ordered_array.hpp

*** File '(Unnamed)'

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc
main.cpp
main.cpp
pushBack.cpp
pushBack.cpp
pushBack.cpp
pushBack.cpp
pushBack.cpp
pushBack.cpp
pushBack.cpp
pushBack.cpp
ordered_array.cpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Mon Feb 17 21:52:22 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
pushBack.cpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Mon Feb 17 21:52:22 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
assign1_test.cpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Mon Feb 17 21:52:22 2020
*** JOE was aborted by UNIX signal 1

*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Mon Feb 17 21:59:44 2020
*** JOE was aborted because the terminal closed

*** File 'ordered_array.hpp'

*** These modified files were found in JOE when it aborted on Mon Feb 17 21:59:44 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.cpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Mon Feb 17 21:59:44 2020
*** JOE was aborted by UNIX signal 15

*** File 'assign_test.cpp'

*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
assign_test.cpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Mon Feb 17 23:09:10 2020
*** JOE was aborted because the terminal closed

*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Mon Feb 17 23:09:10 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.cpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Mon Feb 17 23:09:10 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Mon Feb 17 23:09:10 2020
*** JOE was aborted by UNIX signal 15

*** File 'ordered_array.hpp'
#include <stdexcept> // For out_of_range
#include <iostream>

class ordered_array {
  public:
    /* constructor
       Construct a new ordered_array with the given capacity (maximum size).
       The size of a new ordered_array should be 0.
    */

    ordered_array(int cap) 
	{ 
	pointer = new int[cap];
	capac = cap;
	size2 =0;

	
	}
	
	ordered_array(const ordered_array& other) 
	{ 
	
	capac = other.capac;
	size2 = other.size2;
       pointer = new int[capac];
	
	for(int i = 0; i < size(); ++i)
      pointer[i] = other.pointer[i];

	}


 
    // destructor
    ~ordered_array() { delete []pointer; }

    /* size()
       Returns the size (number of elements in the array).
    */

    int size() { return size2;}


    /* capacity()
       Returns the maximum size of the array.
    */

    int capacity() { return capac;}
	
    /* insert(e)
       Insert e into the array. Note that it is OK to insert duplicates; if n 
       copies of a value are inserted into the array then n copies should appear
       in the array.

       If size() == capacity() then this does nothing.

       If e == -2147483648 then this does nothing (i.e., -2147483648 is not a
       valid value to insert).
    */

    void insert(int elem)
   {
    if(size()== capacity())
       { return;       }       
     if (elem != -2147483648)
     {
      if (size()==0)
      { pointer[0] = elem; 
        size2++;
        }
        
        else if(size()< capacity())       
         {  
           pointer[size()]= elem;
              
            for(int i=0; i<size(); i++)
      	   {
             if (pointer[i] > elem )        
              {std::swap(pointer[i], pointer[size()]);
              
              } 	  
            else if (pointer[size()-1] == elem)
            {break;}


            }           
            size2++;       
          }
        }      
     	 
	 }

    /* remove(e)
       Remove e from the array, if it exists. (If it does not exist, the
       array should be unchanged.) If multiple copies of e are present, only
       one should be removed.

       If e = -2147483648 then this does nothing.
    */
   
    void remove(int elem)
    {
    int i;
    if(size()==0) { return;}
    
     if(size()!=0)
     {           
      for( i =0; i<size(); i++)
       {
       if (pointer[i] == elem)
        { break;}
       }  
        if( i==size()) {return;}      
         else if( i<size())
         {  std::swap(pointer[i], pointer[size()]);                     
            size2--;                    
         }     
     }    
    }


    /* exists(e)
       Returns true if e is present at least once in the array.
              If e == -2147483648 then this returns false.
    */

    bool exists(int elem)
    { 
         if(elem == -2147483648)
           	{return false;}
         else if (size2 == 0)  {return false;}  	
        
        else{        
        for(int i = 0; i<size();  i++)
	     {
          if (pointer[i] == elem)
	      	 {
             return true;
             break;
             }
          } 
      }  	
    }                 
    
     
    /* at(i)
       Returns the value in the array at index i, which should be >= 0 and <
       size(). 

       If i < 0 or i >= size(), then at(i) should throw a std::out_of_range
       exception. (This is what std::vector does in this situation.)

       Note that at() should *never* return -2147483648 (because insert() should
       never insert it).
   */

      
       int at(int i)
       {
        	if(i>=0 && i<size())
        	{
                for(i=0; i<size(); i++)
                 {   	
            	// if(pointer[i]>pointer[i+1])
                // { std:: swap( pointer[i],pointer[i+1]);}
                   return pointer[i];
                 }    	
            	    
    	   // return pointer[i];
           // return value;           
           //  break;       
           	}
           	
          
           
        else  
      	{
		throw std::out_of_range("std::out_of_range");
		}

     }

  private:
	int capac;
	int size2;
	int *pointer;

};
*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Mon Feb 17 23:09:10 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
assign1_test.cpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Mon Feb 17 23:09:10 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
assign1_test.cpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Mon Feb 17 23:09:10 2020
*** JOE was aborted by UNIX signal 15

*** These modified files were found in JOE when it aborted on Mon Feb 17 23:09:10 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'

*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
assign1_test.cpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
assign1_test.cpp

*** File '* Startup Log *'

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Mon Feb 17 23:09:10 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'

*** These modified files were found in JOE when it aborted on Mon Feb 17 23:09:10 2020
*** JOE was aborted by UNIX signal 15
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
assign1_test.cpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Mon Feb 17 23:09:10 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
assign1_test.cpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Mon Feb 17 23:09:10 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Tue Feb 18 16:53:00 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Tue Feb 18 16:53:00 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
assign1_test.cpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Tue Feb 18 16:53:00 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Tue Feb 18 16:53:00 2020
*** JOE was aborted by UNIX signal 15

*** File 'ordered_array.hpp'
#include <stdexcept> // For out_of_range
#include <iostream>

class ordered_array {
  public:
    /* constructor
       Construct a new ordered_array with the given capacity (maximum size).
       The size of a new ordered_array should be 0.
    */

    ordered_array(int cap) 
	{ 
	pointer = new int[cap];
	capac = cap;
	size2 =0;
	}
	
	ordered_array(const ordered_array& other) 
	{ 
	
	capac = other.capac;
	size2 = other.size2;
       pointer = new int[capac];
	
	for(int i = 0; i < size(); ++i)
      pointer[i] = other.pointer[i];

	}


 
    // destructor
    ~ordered_array() { delete []pointer; }

    /* size()
       Returns the size (number of elements in the array).
    */

    int size() { return size2;}


    /* capacity()
       Returns the maximum size of the array.
    */

    int capacity() { return capac;}
	
    /* insert(e)
       Insert e into the array. Note that it is OK to insert duplicates; if n 
       copies of a value are inserted into the array then n copies should appear
       in the array.

       If size() == capacity() then this does nothing.

       If e == -2147483648 then this does nothing (i.e., -2147483648 is not a
       valid value to insert).
    */

    void insert(int elem)
   {
   if(size()== capacity())
       { return;       }   
    
      if (elem != -2147483648)
     {
      if (size()==0)
      { pointer[0] = elem; 
        size2++;
        }
        
        else if(size()< capacity())       
         {  
           pointer[size()]= elem;
           size2++;   
            for(int i=0; i<size(); i++)
      	   {
      	    for(int j=0; j<size()-1; j++)
            { if (pointer[j] > pointer[j+1])        
              {std::swap(pointer[j], pointer[j+1]);
              
              } 	  
             }           
            
            }                  
         size2++;
          }
        }      
     	 
	 }

    /* remove(e)
       Remove e from the array, if it exists. (If it does not exist, the
       array should be unchanged.) If multiple copies of e are present, only
       one should be removed.

       If e = -2147483648 then this does nothing.
    */
   
    void remove(int elem)
    {
    int i;
    if(size()==0) { return;}
    
     if(size()!=0)
     {           
      for( i =0; i<size(); i++)
       {
       if (pointer[i] == elem)
        { break;}
       }  
         if( i<size())
         {  std::swap(pointer[i], pointer[size()]);                     
            size2--;                    
         }     
         size2--;
     }    
    }


    /* exists(e)
       Returns true if e is present at least once in the array.
              If e == -2147483648 then this returns false.
    */

    bool exists(int elem)
    { 
         if(elem == -2147483648)
           	{return false;}
         else if (size2 == 0)  {return false;}  	
        
        else{        
        for(int i = 0; i<size();  i++)
	     {
          if (pointer[i] == elem)
	      	 {
               break;
             }
          } 
             return true;    
      }  	
    }                 
    
     
    /* at(i)
       Returns the value in the array at index i, which should be >= 0 and <
       size(). 

       If i < 0 or i >= size(), then at(i) should throw a std::out_of_range
       exception. (This is what std::vector does in this situation.)

       Note that at() should *never* return -2147483648 (because insert() should
       never insert it).
   */

      
       int at(int i)
       {
        
        	if(i>=0 && i<size())
        	{
            for(int i=0; i<size(); i++)
      	    {
             if (pointer[i] > pointer[i+1])        
              {std::swap(pointer[i], pointer[i+1]);
               }
             }  
                 return pointer[i];
           	}           
        else  
      	{
		throw std::out_of_range("std::out_of_range");
		}

     }

  private:
	int capac;
	int size2;
	int *pointer;

};
*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Tue Feb 18 16:53:00 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'

*** These modified files were found in JOE when it aborted on Tue Feb 18 16:53:00 2020
*** JOE was aborted by UNIX signal 15
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
assign1_test.cpp

*** File '(Unnamed)'

*** File '* Startup Log *'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
assign1_test.cpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Tue Feb 18 16:53:00 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Tue Feb 18 16:53:00 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
assign1_test.cpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Tue Feb 18 16:53:00 2020
*** JOE was aborted by UNIX signal 1

*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Mon Mar  2 19:22:30 2020
*** JOE was aborted because the terminal closed

*** These modified files were found in JOE when it aborted on Mon Mar  2 19:22:30 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
prac.cpp
prac.cpp
prac.cpp
prac.cpp
prac.cpp
prac.cpp
prac.cpp
prac.cpp
prac.cpp
prac.cpp
ordered_array.cpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Mon Mar  2 19:22:30 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
prac.cpp
prac.cpp
prac.cpp
prac.cpp
prac.cpp
prac.cpp
prac.cpp
prac.cpp
prac.cpp
prac.cpp
ordered_array.cpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Mon Mar  2 19:22:30 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
prac.cpp
prac.cpp
prac.cpp
prac.cpp
prac.cpp
prac.cpp
prac.cpp
prac.cpp
prac.cpp
prac.cpp
assign1_test.cpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Mon Mar  2 19:22:30 2020
*** JOE was aborted by UNIX signal 15

*** These modified files were found in JOE when it aborted on Mon Mar  2 19:22:30 2020
*** JOE was aborted by UNIX signal 15

*** File 'assign1_test.cpp'

*** File '(Unnamed)'
/*
 * assign1_test.cpp
 * CS 133 Assignment 1 test runner
 */

/* TODO list
   Randomize capacity of constructed arrays.
*/

#include <iostream>
//#include "ordered_array.hpp"

#include <vector>
using std::cout;

#include <algorithm>
#include <functional>
#include <random>
#include <vector>

const int SENTINEL = -2147483648;

/* make_random_vector(len)
   Returns a vector<int> of random values, where each entry is between 0 and
   INT_MAX. The optional second parameter lets you specify the seed to be used 
   for the RNG.
*/
inline std::vector<int> make_random_vector(
    std::size_t len,
    int seed = 1) 
{
    std::default_random_engine generator(seed);
    std::uniform_int_distribution<int> distribution;
    auto gen = std::bind(distribution, generator);

    // Fill with random values
    std::vector<int> ret(len, 0);
    for(std::size_t i = 0; i < len; ++i)
        ret.at(i) = gen() % 100;

    return ret;
}

/* make_random_permutation(len)
   Returns a vector of length len containing a random permutation of the 
   integers 0...len-1. This can, of course, be used to randomly permute any
   vector of length len.
*/
inline std::vector<unsigned> make_random_permutation(
    std::size_t len,
    int seed = 1) 
{
    std::default_random_engine generator(seed);
    std::vector<unsigned> ret(len, 0);

    // Initialize vector to 0...len-1
    for(std::size_t i = 0; i < len; ++i) 
        ret.at(i) = i;

    std::shuffle(ret.begin(), ret.end(), generator);

    return ret;

}

//#include "ordered_array.hpp"

// Included twice to check for functions being defined in header files, non-use
// of #pragma once or include guard.

#include "ordered_array.hpp"

/* The basic tests that are performed are:
  1.  Construct an ordered_array with capacity 60. Check initial size and 
      capacity.
  2.  Inserting the integers -20...+20 in random order (checking the size after
      each insert, and using `exists` to make sure the newly inserted elements
      are present). 
  3.  Verify that exists() returns true for all values in -20...+20
  4.  Inserting duplicates of -20, 0, and 20. We then remove the duplicates,
      checking the size after each to make sure that the duplicates are really
      being added.
  5.  Remove the duplicates, again checking the size after each to make sure that
      `remove()` does not remove more than one element at a time.
  6.  Try to remove values 30, 31, ... which do not exist. Verify that size is
      unchanged.
  7.  Insert values 30, 31, ... until size() == capacity(). Verify that further
      elements are not inserted. 
  8.  Remove values 30, 31, ... 
  9.  Remove values -20...+20 in random order, checking the size after each. 
  10. Verify that size() == 0. 

  After each operation, we verify that the size is what is expected, and that
  the contents of the array are still sorted.
*/

// Helper for printing an ordered_array
void print_array(ordered_array& a) {
    for(int i = 0; i < a.size(); ++i) {
        std::cout << a.at(i);
        if(i != a.size()-1)
            std::cout << ", ";
    }
}

bool is_sorted(ordered_array& a) {
    if(a.size() <= 1)
        return true;
    else {
        for(int i = 0; i < a.size() - 1; ++i)
            if(a.at(i) > a.at(i+1))
                return false;

        return true;
    }
}

bool hides_sentinel(ordered_array& a) {
    for(int i = 0; i < a.size(); ++i)
        if(a.at(i) == SENTINEL) {
            cout << "CHECK: .at(" << i << ") returns -2147483648.\n";
            return false;
        }

    return true;
}

// Returns number of copies of elem in a.
int count(ordered_array& a, int elem) {
    int c = 0;
    for(int i = 0; i < a.size(); ++i)
        if(a.at(i) == elem)
            c++;

    return c;
}

// Returns true if data and a have the same elements (same counts of all elements)
bool same_elements(const std::vector<int>& data, ordered_array& a) {
    for(int e : data) {
        int c = std::count(data.begin(), data.end(), e);
        if(count(a,e) != c)
            return false;
    }

    return true;
}

bool contains_elements(orderedprac.cpp
prac.cpp
prac.cpp
prac.cpp
prac.cpp
prac.cpp
prac.cpp
prac.cpp
prac.cpp
prac.cpp
ordered_array.hpp
_array& a, const std::vector<int>& d, int count) {
    for(int i = 0; i < count; ++i)
        if(!a.exists(d[i]))
            return false;

    return true;
}

/* test_initial()
   Perform tests on an empty ordered array.
*/
bool test_initial(ordered_array& a, int cap) {
    if(a.size() != 0) {
        cout << "CHECK: Size of empty array is not 0.\n";
        return false;
    }

    if(!hides_sentinel(a)) 
        return false;

    // Note that vector::reserve() theoretically can set capacity to anything
    // >= its parameter, but in practice, it tends to use the exact capacity
    // given to it.  
    if(a.capacity() != cap) {
        cout << "CHECK: Capacity of empty array is not " << cap << ".\n";
        return false;
    }

    // If the array is empty, accessing any .at() element should throw. 
    try {
        a.at(0);
        cout << "CHECK: Out-of-range at() must throw std::out_of_range (returned " << a.at(0) << ")\n";
        return false;
    }
    catch(std::out_of_range& e) {
        // Correct behavior
    }
    catch(...) {
        cout << "CHECK: Out-of-range at() threw some other exception\n";
    }

    a.remove(0); // Does not exist
    if(a.size() != 0) {
        cout << "CHECK: removing elements from empty array should not change anything.\n";
        return false;
    }

    return true;
}

bool test_insert(ordered_array& a) {

    // Initialize test data (values in range -20..+20)
    std::vector<unsigned> perm = make_random_permutation(41);
    std::vector<int> data(41);

    for(std::size_t i = 0; i < data.size(); ++i)
        data[i] = static_cast<int>(perm[i]) - 20;

    int size = a.size(); // expected size

    for(int e : data) {
        a.insert(e); size++;

        if(a.size() != size) {
            cout << "CHECK: After " << size << " insert()s, array size() is incorrect (= " 
                 << a.size() << ").\n";
            return false;
        }

        if(!a.exists(e)) {
            cout << "CHECK: After inserting " << e << " element e does not exist().\n";
            return false;
        }

        if(!is_sorted(a)) {
            cout << "CHECK: After inserting " << e << " array is no longer sorted.\n";
            return false;
        }

        if(!contains_elements(a, data, size)) {
            cout << "CHECK: After insert(), array is missing some prev. element(s).\n";
            return false;
        }

        if(!hides_sentinel(a)) 
            return false;
    }

    for(int i = -20; i <= 20; ++i) {
        if(!a.exists(i)) {
            cout << "CHECK: Value " << i << " does not exist in array.\n";
            return false;
        }
    }

    a.insert(SENTINEL);
    if(a.exists(SENTINEL)) {
        cout << "CHECK: Inserting -2147483648 should do nothing.\n";
        return false;
    }
    if(a.size() != size) {
        cout << "CHECK: Inserting -2147483648 should do nothing.\n";
        return false;        
    }
    if(!contains_elements(a, data, size)) {
        cout << "CHECK: Inserting -2147483648 should do nothing.\n";
        return false;         
    }

    return true; // All tests successful
}

bool test_duplicates(ordered_array& a) {
    std::vector<int> data = {-20, 0, 0, 20, 20, 20 };
    int size = a.size(); // Starting size


*** File '* Startup Log *'
\    // First we insert some duplicates...
    for(int e : data) {
        a.insert(e); size++;
        if(a.size() != size) {
           cout << "CHECK: Inserting a duplicate did not increase size().\n";
           return false; 
        }
        if(!is_sorted(a)) {
            cout << "CHECK: after inserting a duplicate the array is no longer sorted.\n";
            return false;
        }

        if(!hides_sentinel(a)) 
            return false;
    }

    // Count to make sure there are the right number of each
    int zeroes = 0, twenties = 0, negtwen = 0;
    for(int i = 0; i < a.size(); ++i)
        if(a.at(i) == 0)
            zeroes++;
        else if(a.at(i) == 20) 
            twenties++;
        else if(a.at(i) == -20)
            negtwen++;   

    if(zeroes != 3 || twenties != 4 || negtwen != 2) {
        Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc
cout << "CHECK: incorrect number of duplicates found.\n";
        return false;
    }
    // And then we remove them
    for(int e : data) {
        a.remove(e); size--;
        if(a.size() != size) {
            cout << "CHECK: Removing a duplicate results in incorrect size (= " 
                 << a.size() << ", expected " << size << ").\n";
            return false;

        }
        if(!is_sorted(a)) {
            cout << "CHECK: after removing a duplicate the array is no longer sorted.\n";
            return false;
        }

        if(!hides_sentinel(a)) 
            return false;
    }

    return true;
}

bool test_removal_nonexistent(ordered_array& a) {
    // Remove some elements that don't exist
    int size = a.size();

    // Make a copy of a.
    std::vector<int> orig(a.size());
    for(int i = 0; i < a.size(); ++i)
        orig.at(i) = a.at(i);

    for(int i = 30; i <= 40; ++i) {    
        a.remove(i);
        if(a.size() != size) {
            cout << "CHECK: Removing non-existent element changed size.\n";
            return false;
        }

        for(int j = 0; j < a.size(); ++j)
            if(a.at(j) != orig.at(j)) {
                cout << "CHECK: Removing non-existent elements changed existing elements.\n";
                return false;
            }

        if(!hides_sentinel(a)) 
            return false;
    }

    a.remove(SENTINEL);
    if(a.size() != size) {
        cout << "CHECK: removing -2147483648 changed size (should do nothing).\n";
        return false;
    }
    for(int j = 0; j < a.size(); ++j)
        if(a.at(j) != orig.at(j)) {
            cout << "CHECK: Removing -2147483648 changed existing elements.\n";
            return false;
        } 
    if(!hides_sentinel(a)) 
        return false;   

    return true;
}

bool test_capacity(ordered_array& a) {
    int count = a.capacity() - a.size(); // How many to insert
    for(int i = 30; i < 30 + count; ++i)
        a.insert(i);

    if(a.size() != a.capacity()) {
        cout << "CHECK: array should be full, but isn't.\n";
        return false;
    }

    // Try inserting elements and verify that size does not change, elements are
    // not added.
    int size = a.size();
    for(int i = 50; i <= 60; ++i) {
        a.insert(i); 
        if(a.size() != size) {
            cout << "CHECK: Inserting when full changed size.\n";
            return false;
        }

        if(a.exists(i)) {
            cout << "CHECK: Inserting when full should not change array contents.\n";
            return false;
        }

        if(!hides_sentinel(a)) 
            return false;
    }

    // Remove the inserted elements
    for(int i = 30; i < 30 + count; ++i) {
        a.remove(i); 
    }

    if(a.size() != a.capacity() - count) {
        cout << "CHECK: Size is wrong after removing elements.\n";
        return false;
    }

    return true;
}

bool test_removal(ordered_array& a) {
    std::vector<int> data(41);
    for(int i = -20; i <= 20; ++i)
        data[i + 20] = i;

    int size = a.size(); // Expected size
    for(int e : data) {
        a.remove(e); size--;

        if(a.size() != size) {
            cout << "CHECK: After removing existing element, size is incorrect.\n";
            return false;
        }

        if(a.exists(e)) {
            cout << "CHECK: After removing unique element, element still exists.\n";
            return false;
        }

        if(!is_sorted(a)) {
            cout << "CHECK: After removing element, array is no longer sorted.\n";
            return false;
        }

        if(!hides_sentinel(a)) 
            return false;
    }

    return true;
}

bool test_final(ordered_array& a) {
    if(a.size() != 0) {
        cout << "CHECK: Size of empty array is not 0.\n";
        return false;
    }

    if(!hides_sentinel(a)) 
        return false;

    return true;
}

bool test_all() {
    ordered_array a(60);

    return test_initial(a,60) &&
           test_insert(a) &&
           test_duplicates(a) &&
           test_removal_nonexistent(a) &&
           test_capacity(a) &&
           test_removal(a) &&
           test_final(a);
}

int main() {
    cout << "---- Beginning ordered_array tests ----\n";
    if(test_all()) {
        cout << "---- All tests successful! ----\n";
        return 0;
    }
    else
        return 1;
}
*** File '(Unnamed)'
prac.cpp
prac.cpp
prac.cpp
prac.cpp
prac.cpp
prac.cpp
prac.cpp
prac.cpp
prac.cpp
prac.cpp
assign1_test.cpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Thu Mar  5 01:29:58 2020
*** JOE was aborted because the terminal closed

*** File '(Unnamed)'
assign2_test.cpp
dlist.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Thu Mar  5 01:29:58 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
ordered_array.hpp
prac.cpp
assign2_test.cpp
assign2_test.cpp
dlist.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_arrary.hpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Thu Mar  5 01:29:58 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
prac.cpp
assign2_test.cpp
assign2_test.cpp
dlist.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Thu Mar  5 01:29:58 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
prac.cpp
assign2_test.cpp
assign2_test.cpp
dlist.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
assign1_test.cpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Thu Mar  5 01:29:58 2020
*** JOE was aborted by UNIX signal 15

*** File 'ordered_array.hpp'
#include <stdexcept> // For out_of_range
#include <iostream>

class ordered_array {
  public:
    /* constructor
       Construct a new ordered_array with the given capacity (maximum size).
       The size of a new ordered_array should be 0.
    */

    ordered_array(int cap) 
	{ 
	pointer = new int[cap];
	capac = cap;
	size2 =0;
	}
	
	ordered_array(const ordered_array& other) 
	{ 
	
	capac = other.capac;
	size2 = other.size2;
       pointer = new int[capac];
	
	for(int i = 0; i < size(); ++i)
      pointer[i] = other.pointer[i];

	}


 
    // destructor
    ~ordered_array() { delete []pointer; }

    /* size()
       Returns the size (number of elements in the array).
    */

    int size() { return size2;}


    /* capacity()
       Returns the maximum size of the array.
    */

    int capacity() { return capac;}
	
    /* insert(e)
       Insert e into the array. Note that it is OK to insert duplicates; if n 
       copies of a value are inserted into the array then n copies should appear
       in the array.

       If size() == capacity() then this does nothing.

       If e == -2147483648 then this does nothing (i.e., -2147483648 is not a
       valid value to insert).
    */

    void insert(int elem)
   {
   if(size()== capacity())
       { return;       }   
    
      if (elem != -2147483648)
     {
      if ( size()< capacity())
      { for(int i=0; i<size(); i++)
      	  //  
      
      
       pointer[0] = elem; 
        size2++;
        }
        
        else if( size()< capacity())       
         {  
           pointer[size()]= elem;
           size2++;   
           
           // for(int i=0; i<size(); i++)
      	  //  {
      	  //  if (pointer[i] > pointer[i+1])        
          //    { int temp;
          //      temp = pointer[i];
         //       pointer[i] = pointer[i+1];
         //       pointer[i+1] = temp;
              
         //     } 	  
           //else if (pointer[j] == pointer[j+1]) 
            
                       
           
          // }                  
         
          }
        }      
     	 
	 }

    /* remove(e)
       Remove e from the array, if it exists. (If it does not exist, the
       array should be unchanged.) If multiple copies of e are present, only
       one should be removed.

       If e = -2147483648 then this does nothing.
    */
   
 void remove(int elem)
 {
    int i;
    if(size()==0) { return;}
    
     if(size()!=0)
     {           
      for( i =0; i<size(); i++)
       {
       if (pointer[i] == elem)
         {  std::swap(pointer[i], pointer[size()]);                     
            size2--;                    
            break;       
         }     
       }    
    }
}

    /* exists(e)
       Returns true if e is present at least once in the array.
              If e == -2147483648 then this returns false.
    */

    bool exists(int elem)
    { 
         if(elem == -2147483648)
           	{return false;}
         else if (size2 == 0)  {return false;}  	
        
        else{        
        for(int i = 0; i<size();  i++)
	     {
          if (pointer[i] == elem)
	      	 {
               break;
             }
          } 
             return true;    
      }  	
    }                 
    
     
    /* at(i)
       Returns the value in the array at index i, which should be >= 0 and <
       size(). 

       If i < 0 or i >= size(), then at(i) should throw a std::out_of_range
       exception. (This is what std::vector does in this situation.)

       Note that at() should *never* return -2147483648 (because insert() should
       never insert it).
   */

      
 int at(int i)
 {
   int temp; 
    	if(i>=0 && i<size())
       	{
          for(int i=0; i<size()-1 ; i++)
          {
            for(int j=i; j<size(); j++)
              {
              if (pointer[j-1] > pointer[j])
               { 
                  temp = pointer[j-1];
                  pointer[j-1]=pointer[j];
                  pointer[j]=temp; 
               // pointer[j] = pointer[j+1];
              // pointer[i+1] = temp;                  
            // std::swap(pointer[j], pointer[j+1]);
               }          
              }
            }          
       return pointer[i];
        }           
        else  
      	{
		throw std::out_of_range("std::out_of_range");
		}     
     }

  private:
	int capac;
	int size2;
	int *pointer;

};
*** File '(Unnamed)'
prac.cpp
assign2_test.cpp
assign2_test.cpp
dlist.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Fri Mar 27 20:53:18 2020
*** JOE was aborted by UNIX signal 1

*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
prac.cpp
prac.cpp
prac.cpp
prac.cpp
scratch.cpp
scratch.cpp
scratch.cpp
scratch.cpp
ordered_array.hpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Sat Mar 28 02:07:11 2020
*** JOE was aborted by UNIX signal 1

*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Sat Mar 28 02:27:20 2020
*** JOE was aborted by UNIX signal 1

*** File '(Unnamed)'
scratch.cpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
assign1_test.cpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Sat Mar 28 02:27:20 2020
*** JOE was aborted by UNIX signal 1

*** File '(Unnamed)'
scratch.cpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Sat Mar 28 02:27:20 2020
*** JOE was aborted by UNIX signal 1

*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Sat Mar 28 02:27:20 2020
*** JOE was aborted by UNIX signal 1

*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
assign1_test.cpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Sat Mar 28 02:27:20 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
assign1_test.cpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Sat Mar 28 02:27:20 2020
*** JOE was aborted by UNIX signal 15

*** File 'ordered_array.hpp'
#include <stdexcept> // For out_of_range
#include <iostream>

class ordered_array {
  public:
    /* constructor
       Construct a new ordered_array with the given capacity (maximum size).
       The size of a new ordered_array should be 0.
    */

    ordered_array(int cap) 
	{ 
	pointer = new int[cap];
	capac = cap;
	size2 =0;
	}
	
	ordered_array(const ordered_array& other) 
	{ 
	
	capac = other.capac;
	size2 = other.size2;
       pointer = new int[capac];
	
	for(int i = 0; i < size(); ++i)
      pointer[i] = other.pointer[i];

	}


 
    // destructor
    ~ordered_array() { delete []pointer; }

    /* size()
       Returns the size (number of elements in the array).
    */

    int size() { return size2;}


    /* capacity()
       Returns the maximum size of the array.
    */

    int capacity() { return capac;}
	
    /* insert(e)
       Insert e into the array. Note that it is OK to insert duplicates; if n 
       copies of a value are inserted into the array then n copies should appear
       in the array.

       If size() == capacity() then this does nothing.

       If e == -2147483648 then this does nothing (i.e., -2147483648 is not a
       valid value to insert).
    */

    void insert(int elem)
   {
   if(size() == capacity())
       { return;       }   
  
   else{
    
     if (elem != -2147483648)
     {
      // if ( size()==0  )
      //{    
       pointer[size()] = elem; 
        size2++;
        }
        
       // else if( size()< capacity())       
       //  {          
       //    pointer[size()]= elem;
       //    size2++;   
        
        
           
           // for(int i=0; i<size(); i++)
      	  //  {
      	  //  if (pointer[i] > pointer[i+1])        
          //    { int temp;
          //      temp = pointer[i];
         //       pointer[i] = pointer[i+1];
         //       pointer[i+1] = temp;
              
         //     } 	  
           //else if (pointer[j] == pointer[j+1]) 
            
                       
           
          // }                  
         
      //    }
      //  }      
     } 	 
 }

    /* remove(e)
       Remove e from the array, if it exists. (If it does not exist, the
       array should be unchanged.) If multiple copies of e are present, only
       one should be removed.

       If e = -2147483648 then this does nothing.
    */
   
 void remove(int elem)
 {
    int i;
    if(size()==0) { return;}
    
     if(size()!=0)
     {           
      for( i =0; i<size(); i++)
       {
       if (pointer[i] == elem)
          {  std::swap(pointer[i], pointer[size()]);                     
            size2--;                    
            break;       
          }     
        }    
      }
}

    /* exists(e)
       Returns true if e is present at least once in the array.
              If e == -2147483648 then this returns false.
    */

    bool exists(int elem)
    { 
        if (size() == 0)  {return false;}  	      
  
        
        if(elem == -2147483648)
           	{return false;}
           	
          else{      
         for(int i = 0; i<size();  i++)
	     {
          if (pointer[i] == elem)
	      	 {
              return true;
              
        
             }
           } 
                  
           //return true;    
         }  	
    }                 
  }  
     
     
    /* at(i)
       Returns the value in the array at index i, which should be >= 0 and <
       size(). 

       If i < 0 or i >= size(), then at(i) should throw a std::out_of_range
       exception. (This is what std::vector does in this situation.)

       Note that at() should *never* return -2147483648 (because insert() should
       never insert it).
   */

      
 int at(int i)
 {
   int temp; 
 
        if( i<0 || i>= size())  
      	{
		throw std::out_of_range("std::out_of_range!!!");
		//return 0; 
		}
    	
    	else
    	{
          for(int i=0; i<size(); i++)
          {
            for(int j=i+1; j<size(); j++)
              {
              if (pointer[i] > pointer[j])
               { 
                  temp = pointer[i];
                  pointer[i]=pointer[j];
                  pointer[j]=temp; 
               // pointer[j] = pointer[j+1];
              // pointer[i+1] = temp;                  
            // std::swap(pointer[j], pointer[j+1]);
                }          
               }
            }          
       return pointer[i];
        }           
             
     }

  private:
	int capac;
	int size2;
	int *pointer;

};
*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Sat Mar 28 02:27:20 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Sat Mar 28 02:27:20 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Sat Mar 28 02:27:20 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Sat Mar 28 02:27:20 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Sat Mar 28 02:27:20 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Sat Mar 28 02:27:20 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Mon Mar 30 17:40:11 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
ordered_array.hpp
scratch.cpp
scratch.cpp
scratch.cpp
scratch.cpp
scratch.cpp
scratch.cpp
ordered_array.hpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Mon Mar 30 19:43:09 2020
*** JOE was aborted because the terminal closed

*** File '(Unnamed)'
mid2.cpp
mid2.cpp
mid2.cpp
mid2.cpp
mid2.cpp
mid2.cpp
mid2.cpp
mid2.cpp
mid2.cpp
mid2.cpp
ordered_array.hpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Mon Mar 30 19:43:09 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
mid2.cpp
mid2.cpp
mid2.cpp
mid2.cpp
mid2.cpp
mid2.cpp
mid2.cpp
mid2.cpp
mid2.cpp
mid2.cpp
ordered_array.cpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Thu Apr  9 02:17:23 2020
*** JOE was aborted because the terminal closed

*** These modified files were found in JOE when it aborted on Thu Apr  9 02:17:23 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
mid2.cpp
mid2.cpp
mid2.cpp
mid2.cpp
mid2.cpp
mid2.cpp
mid2.cpp
mid2.cpp
mid2.cpp
mid2.cpp
assign_test.cpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Thu Apr  9 02:17:23 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
mid2.cpp
mid2.cpp
mid2.cpp
mid2.cpp
mid2.cpp
mid2.cpp
mid2.cpp
mid2.cpp
mid2.cpp
mid2.cpp
assign1_test.cpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Thu Apr  9 02:17:23 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
mid2.cpp
mid2.cpp
mid2.cpp
mid2.cpp
mid2.cpp
mid2.cpp
mid2.cpp
mid2.cpp
mid2.cpp
mid2.cpp
ordered_array.cpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc

*** These modified files were found in JOE when it aborted on Mon Apr 13 02:18:55 2020
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
std::.cpp
std::.cpp
vectorPract.cpp
vectorPract.cpp
vectorPract.cpp
linkedList.cpp
linkedList.cpp
linkedList.cpp
doubLinked.hpp
assign2_test.cpp
ordered_array.hpp

*** File '* Startup Log *'
Processing '/etc/joe/jmacsrc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/jmacsrc
